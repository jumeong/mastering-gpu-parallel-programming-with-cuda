# 48. Roofline Analysis

## 1. 루프라인 분석(Roofline Analysis)의 핵심 개념

루프라인 분석은 GPU 애플리케이션의 성능 병목 지점을 시각적으로 진단하는 가장 강력한 도구입니다.

* **산술 강도 (Arithmetic Intensity, AI):** 메모리에서 1바이트를 가져올 때 수행하는 연산의 횟수 ($Ops/Byte$).
* **전환점 (Transition Point):** GPU의 최대 연산 성능과 최대 메모리 대역폭이 균형을 이루는 지점입니다. (RTX 3060 기준 약 **30.9**)
* **왼쪽 (Memory Bound):** 포인트가 사선 영역에 있으면 메모리 최적화가 시급함.
* **오른쪽 (Compute Bound):** 포인트가 수평 영역에 있으면 연산 최적화가 시급함.

<img width="516" height="388" alt="image" src="https://github.com/user-attachments/assets/1e5207d3-3e54-4dfc-9bbf-54a7db5ffecf" />

---

## 2. 실습: 벡터 리덕션 최적화 전후 비교

강의에서는 베이스라인(v1)과 최적화 버전(v3)의 루프라인 데이터를 직접 비교하여 성능 향상을 증명했습니다.

### 성능 지표 변화 테이블

| 구분 | 베이스라인 (Baseline) | 최적화 버전 (v3/v4) | 변화량 |
| --- | --- | --- | --- |
| **산술 강도 (AI)** | **0.12** | **0.66** | **약 5.5배 증가** |
| **성능 (GFLOPS)** | **15 GFLOPS** | **177 GFLOPS** | **약 11.8배 증가** |

* **분석 결과:** 최적화 후 데이터 포인트가 **오른쪽 상단(전환점 방향)**으로 크게 이동했습니다. 이는 메모리 접근 효율이 개선되면서 동일한 메모리 전송량 대비 더 많은 유효 연산을 처리하고 있음을 의미합니다.

---

## 3. 최적화 방향 가이드

루프라인 분석 결과에 따라 우리가 따라야 할 최적화 경로는 다음과 같습니다.

### **A. 내 포인트가 사선(Memory Bound)에 있을 때**

벡터 리덕션처럼 대다수의 데이터 처리 앱이 여기에 해당합니다.

* **Coalescing:** 메모리 접근을 연속적으로 만들어 대역폭 낭비 방지.
* **Shared Memory:** 반복되는 글로벌 메모리 접근을 줄임.
* **Shuffle Operations:** 레지스터 간 직접 통신으로 공유 메모리 지연 시간조차 제거.

### **B. 내 포인트가 수평선(Compute Bound)에 있을 때**

AI가 충분히 높지만 하드웨어 한계에 부딪힌 경우입니다.

* **Instruction Level Parallelism (ILP):** 루프 언롤링 등을 통해 명령어 병렬성 향상.
* **Fast Math:** 정확도를 조금 희생하더라도 하드웨어 가속기(Intrinsic) 사용.
* **Dependency 제거:** 연산 간의 대기 시간(Stall)을 줄여 코어 가동률 향상.

---

## 4. 결론 및 요약

* 루프라인 분석의 궁극적인 목표는 **애플리케이션의 포인트를 전환점(Transition Point)에 최대한 가깝게 밀어 올리는 것**입니다.
* 단순히 실행 시간만 보는 것이 아니라, **AI와 FLOPS를 함께 분석**해야 진정한 성능 병목 원인을 파악하고 올바른 최적화 도구를 선택할 수 있습니다.
